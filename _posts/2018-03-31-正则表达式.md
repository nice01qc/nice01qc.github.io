---
layout: post
title: "正则表达式"
author: "nice01qc"
categorie: "Others"
excerpt_separator: "..."
---

> 简单地总结正则表达式的语法和使用...



> #### 基础知识 

**在任意位置进行匹配**: 默认情况下, 正则表达式可以匹配被搜索字符串的 *任意位置* 的子字符串. 例如, 正则表达式 abc 可以匹配 abc123, 123abc 以及 123abcxyz. 要限制在开始或末尾进行匹配, 请使用 [锚](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#anchor).

**转义字符**: 大多数字符 (例如 abc123) 可以直接使用在正则表达式中. 然而, **\.\*?+[{|()^$** 这些字符则必须在其前面加上反斜线来进行匹配. 例如, \. 表示一个原义的句点而 \\ 表示一个原义的反斜线. 使用 \Q...\E 能避免转义. 例如: \QLiteral Text\E.

**区分大小写**: 默认情况下, 正则表达式是区分大小写的. 这种特性可以使用 "i" 选项进行改变. 例如, 模式 i)abc 会搜索所有大小写形式的 "abc". 请参阅下面了解其他的选项.

> #### 选项 (区分大小写)

在正则表达式的最前面, 指定零个或多个下列选项后面跟着闭括号. 例如, 模式 "im)abc" 将带有不区分大小写和多行选项来搜索 *abc* (如果不含选项, 则这个圆括号可以省略). 尽管这种语法有别于传统, 不过它不需要特殊的分隔符 (例如正斜杠), 因此不需要对模式中的这样的分隔符进行转义. 此外, 由于很容易解析出选项, 所以提升了性能.

| **i**  | 不区分大小写匹配, 它把字母 A 到 Z 视为等同于它们的小写副本.  |
| ------ | ------------------------------------------------------------ |
| **m**  | 多行. 把*Haystack*视为许多单独的行（如果它包含新行符）的集合而不是一个单个的连续行。具体地, 它会改变下列方式:1) 抑扬符 (^) 能匹配紧跟在内部所有新行符之后的位置, 如同它总能匹配 *Haystack* 的开始处一样 (但它不会匹配 *Haystack* 的 *最后面* 的新行符之后的位置).2) 美元符 ($) 能匹配 *Haystack* 中任何新行符之前的位置 (如同它总能匹配最后面的位置).例如，模式“m)^abc$”中包含了“m”选项才能在 *Haystack*“xyz`r`nabc”中形成匹配。使用了 "m" 选项时 "D" 选项会被忽略. |
| **s**  | DotAll. 此选项会让句点 (.) 匹配包含新行符在内的所有字符 (一般情况下, 它不能匹配新行符). 然而, 如果换行符是默认的 CRLF (`r`n), 则必须使用两个句点才能进行匹配 (不是一个). 不论是否使用此选项, 排除型字符类 (例如 [^a]) 总能匹配新行符. |
| **x**  | 忽略模式中的空白字符, 除非对它们进行转义或出现在字符类中. 字符 `n 和 `t 在它们达到 PCRE 时会被忽略, 因为它们已经是原始的/原义的空白字符 (与之相比, \n 和 \t 则不会被忽略, 因为它们是 PCRE 的转义序列). **x** 选项还会忽略字符类外面的非转义 # 和下一个新行符之间的字符 (包括它们). 这使得在复杂的模式中添加注释成为可能. 然而, 这只适用于数据字符; 空白字符可能永远都不会出现在特殊字符序列中, 例如 (?(, 它以条件子模式开头. |
| **A**  | 强制固定匹配模式; 即它只能匹配 *Haystack* 的开始处 (即使开始处是换行符, 也会从换行符开始匹配而不从换行符之后的字符开始). 在大多数条件下, 它的作用等同于在模式中使用 "^". |
| **D**  | 强制美元符 ($) 匹配 *Haystack* 的末端, 即使 *Haystack* 的最后的字符是新行符. 如果没有此选项，则$会匹配最后的新行符之前的位置（如果有新行符，此时匹配不会包括新行符）。注: 使用了 "m" 选项时此选项会被忽略. |
| **J**  | 允许重复 [命名子模式](https://ahkcn.github.io/docs/commands/RegExMatch.htm#NamedSubPat). 它可用于在一组相同的命名子模式中只有其中一个形成匹配的模式. 注: 如果有多个特殊名子模式的实例形成匹配, 那么只保存最左边的那个. 此外, 变量名不区分大小写. |
| **U**  | 非贪婪. 让限定符 *+?{} 在形成匹配时只消耗必需的那些字符, 把剩下的部分留给模式的后面部分. 没有使用 "U" 选项时, 可以在这些字符后加上问号来限定它们为非贪婪的. 相反地, *使用了* "U" 选项时, 问号会成为贪婪匹配的限定符. |
| **X**  | PCRE_EXTRA. 启用不兼容 Perl 的 PCRE 功能. 目前, 这样的唯一功能是在模式中的任意反斜线后跟着没有特殊含义的字母时会导致匹配失败并因此设置 ErrorLevel. 此选项会帮助保留未使用的反斜线序列供将来使用. 如果没有此选项, 反斜线后跟着没有特殊含义的字母时会被视为原义的 (即 \g 和 g 都被识别为原义的 g). 不论是否使用此选项, 没有特殊含义的非字母反斜线序列总是被视为原义的 (即 \/ 和 / 都被视为正斜杠). |
| **P**  | 位置模式. 这会使 RegExMatch() 产生匹配和其子模式的位置和长度而不是匹配它们的子字符串. 更多细节请参阅 [UnquotedOutputVar](https://ahkcn.github.io/docs/commands/RegExMatch.htm#PosMode)。 |
| **S**  | 研究模式来提高性能. 它可用于要执行多次的特殊模式 (尤其是复杂的模式). 如果 PCRE 找到了提高性能的方法, 则会把这个发现储存到缓存中模式的旁边, 以便在之后执行相同模式时使用 (后续使用此模式时还需要指定 S 选项, 因为要找到缓存中相同的模式则它们的选项也必须完全相同, 包括它们的顺序). (这里的研究主要指在进行匹配前使用其他一些通常较简单快速的方法进行判断, 例如假设模式至少匹配 5 个字符, 而源字符串只有 3 个, 那么正则表达式引擎会直接返回 "没有匹配" 的结果, 而不会进行匹配.) |
| **C**  | 启用自动调出模式。请参阅[正则表达式调出](https://ahkcn.github.io/docs/misc/RegExCallout.htm#auto)了解更多信息。 |
| **`n** | 从默认的新行符 (`r`n) 切换到单独的换行符 (`n), 这是 UNIX 系统的标准. 所选择的新行符会影响 [锚 (^ 和 $)](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#anchor) 和 [含句点的模式](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#dot). |
| **`r** | 从默认的新行符 (`r`n) 切换到单独的回车符 (`r).               |
| **`a** | 在 v1.0.46.06+, `a 可以识别任意类型的新行符, 即 `r, `n, `r`n, `v/VT/vertical tab/chr(0xB), `f/FF/formfeed/chr(0xC) 以及 NEL/next-line/chr(0x85). 在 v1.0.47.05+，新行符可以被限制为 CR、LF 和 CRLF 三种，只需要在模式的开始处（选项后面）指定大写的（*ANYCRLF）；例如 `im)(*ANYCRLF)^abc$`。 |

注: 在两个选项间可以使用空格或 tab 分隔.

#### 常用符合和用法

| **.**              | 默认情况下, 句点匹配除新行符 (`r`n) 序列外的任何单个字符, 但是这种特性可以使用 [DotAll (s)](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#opt_s), [新行 (`n)](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#opt_esc_n), [回车 (`r)](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#opt_esc_r), [`a 或 (*ANYCRLF)](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#NEWLINE_ANY) 选项进行改变. 例如, ab. 可以匹配 abc 和 abz 以及 ab_. |
| ------------------ | ------------------------------------------------------------ |
| *****              | 星号匹配零个或多个前面的字符, [字符类](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#class) 或 [子模式](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#subpat). 例如, a* 可以匹配 ab 和 aaab. 它还可以匹配完全不包含 "a" 的任意字符串的开始处.**通配符:** 句点星号模式 .* 是匹配范围最广的模式之一, 因为它可以匹配零个或多个 *任意* 字符 (除了新行符: `r 和 `n). 例如, abc.*123 可以匹配 abcAnything123, 也能匹配 abc123. |
| **?**              | 问号匹配零或一个前面的字符, [字符类](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#set) 或 [子模式](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#subpat). 可以理解为 "前面的那项是可选的". 例如, colou?r 可以匹配 color 和 colour, 因为 "u" 是可选的. |
| **+**              | 加号匹配一个或多个前面的字符, [字符类](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#class) 或 [子模式](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#subpat). 例如 a+ 可以匹配 ab 和 aaab. 但与 a* 和 a? 不同的是, 模式 a+ 不会匹配开始处没有 "a" 的字符串. |
| {min,max}          | 匹配出现次数介于 *min* 和 *max* 的前面的字符, [字符类](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#set) 或 [子模式](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#subpat). 例如, a{1,2} 可以匹配 ab 但只匹配 aaab 中的前两个 a.此外, {3} 表示准确匹配 3 次, 而 {3**,**} 则表示匹配 3 次或更多. 注: 指定的数字必须小于 65536, 且第一个必须小于等于第二个. |
| **[...]**          | **字符类:** 方括号把一列字符或一个范围括在了一起 (或两者). 例如, [abc] 表示 "a, b 或 c 的中任何一个字符". 使用破折号来创建范围; 例如, [a-z] 表示 "在小写字母 a 和 z (包含的) 之间的任何一个字符". 列表和范围可以组合在一起; 例如 [a-zA-Z0-9_] 表示 "字母, 数字或下划线中的任何一个字符".字符类后面可以使用 *, ?, + 或 {min,max} 进行限定. 例如, [0-9]+ 匹配一个或多个任意数字; 因此它可以匹配 xyz123 但不会匹配 abcxyz.通过 [[:xxx:]] 还支持下列 POSIX 命名集, 其中 xxx 是下列单词的其中一个: alnum, alpha, ascii (0-127), blank (space 或 tab), cntrl (控制字符), digit (0-9), xdigit (十六进制数), print, graph (排除了空格的打印字符), punct, lower, upper, space (空白), word (等同于 [\w](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#word)).在字符类中, 只有在类中具有特殊含义的字符才需要进行转义; 例如 [\^a], [a\-b], [a\]] 和 [\\a]. |
| **[^...]**         | 匹配 **不** 在类中的任何一个字符. 例如, [^/]* 匹配零个或多个 *不是* 正斜杠的任意字符, 例如 http://. 同样地, [^0-9xyz] 匹配既不是数字也不是 x, y 或 z 的任何一个字符. |
| **\d**             | 匹配任意一个数字 (相当于类 [0-9]). 相反地，大写的\D表示“任意的*非*数字字符”。这个和下面的两个都可以用在 [字符类](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#set) 中; 例如, [\d.-] 表示 "任何数字, 句点或负号". |
| **\s**             | 匹配任意单个空白字符 , 主要是空格, tab 和新行符 (`r 和 `n). 相反地, 大写的 \S 表示 "任何 *非*空白字符". |
| **\w**             | 匹配任何单个 "单词" 字符, 即字母, 数字或下划线. 这等同于 [a-zA-Z0-9_]. 相反地, 大写的 \W 表示 "任何 *非*单词字符". |
| **^$**             | 抑扬符 (^) 和美元符 ($) 被称为 *锚*, 因为它们不消耗任何字符; 相反地, 它们把模式限定在被搜索字符串的开始或末尾进行匹配.在模式的开始处使用 ^ 表示需要在行的开始处进行匹配. 例如, ^abc 可以匹配 abc123 但不匹配 123abc.在模式的末尾处使用 $ 表示需要在行的末端进行匹配. 例如, abc$ 可以匹配 123abc 但不能匹配 abc123.这两个锚还可以组合使用. 例如, ^abc$ 仅匹配 abc (即在它的前面或后面不能有另外的字符).如果被搜索的文本包含多行, 则可以使用 ["m" 选项](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#Multiline) 让锚应用于每行而不是把所有文本作为整体. 例如, m)^abc$ 可以匹配 123`r`nabc`r`n789. 但如果没有 "m" 选项, 则不会形成匹配. |
| **\b**             | \b 表示 "单词边界", 它类似锚, 因为它不消耗任何字符. 它要求当前字符的 [状态为单词字符 (\w)](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#word), 与前一个字符的状态相反. 它通常用来避免意外地匹配到在其他单词内的某个单词. 例如, \bcat\b 不会匹配 catfish, 但它可以匹配不论周围是否有标点或空白的 cat. 大写的 \B 则相反: 它要求当前字符 *不是* 单词的边界. |
| **\|**             | 竖线将两个或多个可选项目分隔开来. 如果可选项目中 *任何一个* 满足条件, 则会形成匹配. 例如, gray\|grey 既可以匹配 gray 也可以匹配 grey. 同样地, 模式 gr(a\|e)y 中通过下面描述的括号的帮助可以实现同样的作用. |
| **(...)**          | 括在括号中的项目常用于:确定求值的顺序. 例如, (Sun\|Mon\|Tues\|Wednes\|Thurs\|Fri\|Satur)day 可以匹配任何一天的名称.把 *, ?, + 或 {min,max} 应用到 *系列* 字符而不只是单个字符. 例如, (abc)+ 匹配一个或一串字符串 "abc"; 因此它可以匹配 abcabc123 但不会匹配 ab123 或 bc123.捕获子模式, 例如 abc(.*)xyz 中的句点星号. 例如, [RegExMatch()](https://ahkcn.github.io/docs/commands/RegExMatch.htm) 会把匹配每个子模式的子字符串保存到 [输出数组](https://ahkcn.github.io/docs/commands/RegExMatch.htm#Array). 同样地, [RegExReplace()](https://ahkcn.github.io/docs/commands/RegExReplace.htm) 中允许把匹配每个子模式的子字符串通过像 $1 这样的 [后向引用](https://ahkcn.github.io/docs/commands/RegExReplace.htm#BackRef) 重新插入到替换结果中. 要使用不捕获子模式的括号, 请把括号内的开始两个字符指定为 ?:; 例如: (?:.*)在匹配过程中改变 [选项](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#Options). 例如, (?im) 会为模式的后续部分打开不区分大小写和多行选项 (如果它在子模式中则它会改变子模式的选项). 相反地, (?-im) 会关闭它们. 支持除 DPS`r`n`a 外的所有选项. |
| **\t\r等等.**      | 这些转义序列表示特殊的字符. 最常见的有 \t (tab), \r (回车) 和 \n (换行). 在 AutoHotkey, 在这些情况中还可以使用重音符 (`) 代替反斜线. 还支持 \xhh 格式的转义序列, 其中 *hh* 是介于 00 和 FF 之间的任意 ANSI 字符的十六进制码.在 v1.0.46.06+, \R 表示 "单个任意类型的新行符", 即在 [`a 选项](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#NEWLINE_ANY) 中列出的这些 (然而, \R 在 [字符类](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#class) 中仅仅表示字母 "R"). 在 v1.0.47.05+, \R 可以被限制为 CR, LF 和 CRLF 三种, 只需要在模式的开始处 (选项后面) 指定大写的 (*BSR_ANYCRLF) ; 例如 im)(*BSR_ANYCRLF)abc\Rxyz |
| **\p{xx}\P{xx}\X** | [AHK_L 61+]: Unicode 字符属性. 在 ANSI 版本中不支持. \p{xx} 匹配带 xx 属性的字符而 \P{xx} 匹配 *不带* xx 属性的任意一个字符. 例如, \pL匹配任意一个字母而 \p{Lu} 匹配任意一个大写字母. \X 匹配组成扩展 Unicode 序列的任何数目的字符.对于受支持的属性名称的完整列表和其他细节, 请在 [www.pcre.org/pcre.txt](http://www.pcre.org/pcre.txt) 中搜索 "\p{xx}". |
| **(\*UCP)**        | [AHK_L 61+]: 考虑到性能, \d, \D, \s, \S, \w, \W, \b 和 \B 默认情况下只识别 ASCII 字符, 即使在 Unicode 版本中也是如此. 如果模式以 (*UCP)开头, 则会使用 Unicode 属性来判断哪个字符匹配. 例如, \w 变成相当于 [\p{L}\p{N}_] 而 \d 变成等同于 \p{Nd}. |



**贪婪**：默认情况下，*、?、+ 和 {min,max} 是贪婪的，因为它们消耗到*最后一个*能满足整个模式的可能的所有字符。要让它们停在 *首个* 可能的字符, 请在它们后面加上问号. 例如, 模式 <.+> (其中没有问号) 表示: "搜索一个 <, 接着一个或多个任意字符, 然后是一个 >". 要在匹配 *整个* 字符串 **<**em>text</em**>** 时停止, 请在加号后加上问号: <.+?>. 这样会让匹配在第一个 '>' 处停止, 因此它只匹配第一个标签 **<**em**>**.

**预测和回顾断言**：这组 (?=...)、(?!...)、(?<=...) 和 (?<!...) 被称为*断言*，因为它们要求符合某个条件但不消耗任何字符。例如, abc(?=.*xyz) 中含有预测断言, 它要求在字符串 abc 右边的某个位置存在字符串 xyz (如果不存在, 则匹配失败). (?=...) 被称为 *正* 预测断言, 因为它要求指定的模式存在. 相反地, (?!...)是 *负* 预测断言, 因为它要求指定的模式 *不* 存在. 同样地, (?<=...) 和 (?<!...) 分别是正的和负的 *回顾* 断言, 因为它们检查当前位置的 *左边* 而不是右边. 回顾比预测受到更多的限制, 因为它们不支持可变大小的限定符, 例如 *, ? 和 +. 转义序列 \K 类似于回顾断言, 因为它会让前一个匹配的字符在最后的匹配字符串中省略. 例如, foo\Kbar 可以匹配 "foobar" 但报告匹配的结果为 "bar".

#### Java正则

```java
Pattern.matches("\\d+","2223");//返回true 

Pattern p=Pattern.compile("([a-z]+)(\\d+)"); 
Matcher m=p.matcher("aaa2223bb"); 
// 必须调用find ,然后才能使用start,end,group等需要初始化原始数据的方法
m.find();   //匹配aaa2223 	
m.groupCount();   //返回2,因为有2组 
m.start(1);   //返回0 返回第一组匹配到的子字符串在字符串中的索引号 
m.start(2);   //返回3 
m.end(1);   //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置
m.end(2);   //返回7 
m.group(1);   //返回aaa,返回第一组匹配到的子字符串 
m.group(2);   //返回2223,返回第二组匹配到的子字符串 
```



**参考资源：**

> [正则表达式（RegEx）——快速参考](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#Common)

> [JAVA正则表达式：Pattern类与Matcher类详解(转)](https://www.cnblogs.com/ggjucheng/p/3423731.html)