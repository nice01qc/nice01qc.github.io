---
layout: post
title: "正则表达式"
author: "nice01qc"
categorie: "Others"
excerpt_separator: "..."
---

> 简单地总结正则表达式的语法和使用...



#### 常用符合和用法

| **\.** | 默认情况下, 句点匹配除新行符 (\\r\\n) 序列外的任何单个字符, 但是这种特性可以使用  选项进行改变. 例如, ab. 可以匹配 abc 和 abz 以及 ab_. |
| ------------------ | ----------------------------------------|
| **\***              | 星号匹配零个或多个前面的字符 |
| **\?**              | 问号匹配零或一个前面的字符 |
| **\+**              | 加号匹配一个或多个前面的字符 |
| {min,max}          | 匹配出现次数介于 *min* 和 *max* 的前面的字符 |
| **[\.\.\.\]**          | 字符范围 |
| **[^...]**         | 匹配 **不** 在类中的任何一个字符.  |
| **\\d **     | 匹配任意一个数字 (相当于类 \[0-9\]). 相反地，大写的\\D表示“任意的*非*数字字符” |
| **\\s**             | 匹配任意单个空白字符 , 主要是空格, tab 和新行符 |
| **\\w**             | 这等同于 [a-zA-Z0-9_]. 相反地, 大写的 \\W 表示 "任何 *非*单词字符". |
| **^\$**             | 抑扬符 \(\^\) 和美元符 \(\$\) 被称为 *锚*, 因为它们不消耗任何字符; 相反地, 它们把模式限定在被搜索字符串的开始或末尾进行匹配.|
| **\\b**             | \b 表示 "单词边界", 它类似锚, 因为它不消耗任何字符. |
| **\|**             | 竖线将两个或多个可选项目分隔开来. |
| **\(...\)**          | 括在括号中的项目常用于:确定求值的顺序. |
|**(?: ...)**|匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。|

**贪婪**：默认情况下，*、?、+ 和 {min,max} 是贪婪的，因为它们消耗到*最后一个*能满足整个模式的可能的所有字符。要让它们停在 *首个* 可能的字符, 请在它们后面加上问号. 例如, 模式 <.+> (其中没有问号) 表示: "搜索一个 <, 接着一个或多个任意字符, 然后是一个 >". 要在匹配 *整个* 字符串 **<**em>text</em**>** 时停止, 请在加号后加上问号: <.+?>. 这样会让匹配在第一个 '>' 处停止, 因此它只匹配第一个标签 **<**em**>**.

**预测和回顾断言**：这组 (?=...)、(?!...)、(?<=...) 和 (?<!...) 被称为*断言*，因为它们要求符合某个条件但不消耗任何字符。例如, abc(?=.*xyz) 中含有预测断言, 它要求在字符串 abc 右边的某个位置存在字符串 xyz (如果不存在, 则匹配失败). (?=...) 被称为 *正* 预测断言, 因为它要求指定的模式存在. 相反地, (?!...)是 *负* 预测断言, 因为它要求指定的模式 *不* 存在. 同样地, (?<=...) 和 (?<!...) 分别是正的和负的 *回顾* 断言, 因为它们检查当前位置的 *左边* 而不是右边. 回顾比预测受到更多的限制, 因为它们不支持可变大小的限定符, 例如 *, ? 和 +. 转义序列 \K 类似于回顾断言, 因为它会让前一个匹配的字符在最后的匹配字符串中省略. 例如, foo\Kbar 可以匹配 "foobar" 但报告匹配的结果为 "bar".

#### Java正则

```java
Pattern.matches("\\d+","2223");//返回true 

Pattern p=Pattern.compile("([a-z]+)(\\d+)"); 
Matcher m=p.matcher("aaa2223bb"); 
// 必须调用find ,然后才能使用start,end,group等需要初始化原始数据的方法
m.find();   //匹配aaa2223 	
m.groupCount();   //返回2,因为有2组 
m.start(1);   //返回0 返回第一组匹配到的子字符串在字符串中的索引号 
m.start(2);   //返回3 
m.end(1);   //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置
m.end(2);   //返回7 
m.group(1);   //返回aaa,返回第一组匹配到的子字符串 
m.group(2);   //返回2223,返回第二组匹配到的子字符串 
```



**参考资源：**

> [正则表达式（RegEx）——快速参考](https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm#Common)

> [JAVA正则表达式：Pattern类与Matcher类详解(转)](https://www.cnblogs.com/ggjucheng/p/3423731.html)

> [正则表达式——菜鸟 教程](http://www.runoob.com/regexp/regexp-syntax.html)