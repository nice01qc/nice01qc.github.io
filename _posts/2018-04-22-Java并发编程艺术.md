---
layout: post
title: "Java并发编程艺术"
author: "nice01qc"
categories: "Java"
excerpt_separator: "..."
---

> Java并发编程艺术知识点总结...

## Java并发编程基础

### Daemon线程

是一种支持型线程，当Java虚拟机中不存在`Daemon`线程时，Java虚拟机将会退出，而不会管`Daemon`线程时候执行完毕。通过`Thread.setDaemon(true)`设置为`Daemon`线程。



### [线程中断](https://www.ibm.com/developerworks/cn/java/j-jtp05236.html)

当线程被阻塞时，此时被中断会抛出`InterruptedException`异常，并使中断标识符复位`false`，阻塞方法有Thread.sleep(), Object.wait(), Thread.join()....，其中IO阻塞是不会抛出异常，也不会提前返回。

没被阻塞的线程，其中断标识会变为`ture`。

如何处理`InterruptedException`: 

1. 通常通过throws 抛出异常

2. 如果在抛出异常时，还要做些其他处理，可以`try-catch`捕获异常

3. 也可以不抛出异常，在catch里面再次`Thread.currentThread().interrupt();`中断线程

   ​

### 线程间的通信

##### `volatile` & `synchronized` 关键字

`volatile`修饰一个字段

`synchronized`修饰方法或者同步快

```java
// 修饰一个代码块
synchronized(this) {
         // do something
}
// 修饰一个方法
public synchronized void method1(){
    // do something
}
// 修饰一个静态方法
public synchronized static void method2(){
    // do something
}
// 修饰一个类
synchronized(ClassName.class){
    // do something
}
```



| 方法名         | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| notify()       | 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是获取到了对象的锁 |
| notifyAll()    | 通知所有等待在该对象上的线程                                 |
| wait()         | 通过该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁。 |
| wait(long)     | 超时等待一段时间（毫秒），没有通知则超时返回                 |
| wait(long,int) | int 处为纳秒                                                 |

**注意：**

- 使用wait(),notify() 和 notifyAll() 时需要先对调用对象加锁
- 调用wait()方法后，线程状态由RUNNING 变成WAITING，并将当前线程放置到对象等待队列。
- notify() 或notifyAll() 方法调用后，等待线程依旧不会从wait() 返回，需要调用notify()或notifyAll()的线程释放锁以后，等待线程才有机会从wait()返回。
- notify(）只通知一个，使其状态由Waiting -> Blocked
- wait() 方法返回的前提是获得调用对象的锁

```java
public class WaitNotify {
    static Object lock = new Object();
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new Wait());
        thread.start();
        TimeUnit.SECONDS.sleep(2);
        synchronized (lock){
            lock.notify();
        }
    }

    static class Wait implements Runnable{
        @Override
        public void run() {
            synchronized (lock){
                try {
                    lock.wait(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("finally");
            }
        }
    }
}
```
















**参考资源：

> [Java 理论与实践: 处理 InterruptedException](https://www.ibm.com/developerworks/cn/java/j-jtp05236.html)

> [《Java并发编程的艺术》](https://book.douban.com/subject/26591326/)



















