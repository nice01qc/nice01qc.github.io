---
layout: post
title: "Java并发编程艺术"
author: "nice01qc"
categories: "Java"
excerpt_separator: "..."
---

> Java并发编程艺术知识点总结...

## Java并发编程基础

### Daemon线程

是一种支持型线程，当Java虚拟机中不存在`Daemon`线程时，Java虚拟机将会退出，而不会管`Daemon`线程时候执行完毕。通过`Thread.setDaemon(true)`设置为`Daemon`线程。



### [线程中断](https://www.ibm.com/developerworks/cn/java/j-jtp05236.html)

当线程被阻塞时，此时被中断会抛出`InterruptedException`异常，并使中断标识符复位`false`，阻塞方法有Thread.sleep(), Object.wait(), Thread.join()....，其中IO阻塞是不会抛出异常，也不会提前返回。

没被阻塞的线程，其中断标识会变为`ture`。

如何处理`InterruptedException`: 

1. 通常通过throws 抛出异常

2. 如果在抛出异常时，还要做些其他处理，可以`try-catch`捕获异常

3. 也可以不抛出异常，在catch里面再次`Thread.currentThread().interrupt();`中断线程

   ​

### 线程间的通信

##### `volatile` & `synchronized` 关键字

`volatile`修饰一个字段

`synchronized`修饰方法或者同步快

```java
// 修饰一个代码块
synchronized(this) {
         // do something
}
// 修饰一个方法
public synchronized void method1(){
    // do something
}
// 修饰一个静态方法
public synchronized static void method2(){
    // do something
}
// 修饰一个类
synchronized(ClassName.class){
    // do something
}
```



| 方法名         | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| notify()       | 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是获取到了对象的锁 |
| notifyAll()    | 通知所有等待在该对象上的线程                                 |
| wait()         | 通过该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁。 |
| wait(long)     | 超时等待一段时间（毫秒），没有通知则超时返回                 |
| wait(long,int) | int 处为纳秒                                                 |

**注意：**

- 使用`wait()`,`notify()` 和 `notifyAll()` 时需要先对调用对象加锁
- 调用`wait()`方法后，线程状态由`RUNNING` 变成`WAITING`，并将当前线程放置到对象等待队列。
- `notify()  ` 或 ` notifyAll()` 方法调用后，等待线程依旧不会从`wait()` 返回，需要调用`notify()`或`notifyAll()`的线程释放锁以后，等待线程才有机会从`wait()`返回。
- `notify(）`只通知一个，使其状态由`Waiting -> Blocked`
- `wait()` 方法返回的前提是获得调用对象的锁

```java
public class WaitNotify {
    static Object lock = new Object();
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new Wait());
        thread.start();
        TimeUnit.SECONDS.sleep(2);
        synchronized (lock){
            lock.notify();
        }
    }

    static class Wait implements Runnable{
        @Override
        public void run() {
            synchronized (lock){
                try {
                    lock.wait(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("finally");
            }
        }
    }
}
```

**管道输入输出流PipedOutputStream、PipedInputStream、PipedReader、PipedWrite**

主要用于线程之间的数据传输，传输媒介为内存。

```java
public class Piped {
    public static void main(String[] args) throws IOException {
        PipedWriter out = new PipedWriter();
        PipedReader in = new PipedReader();
        out.connect(in);	// 将输出和输入进行连接，否则会抛出IOException
        Thread printThread = new Thread(new Print(in), "PrintWrite");
        printThread.start();
        int receive = 0;
        try {
            while ((receive = System.in.read()) != 10) {
                out.write(receive);
                System.out.println("receive: " + receive);
            }
        } finally {
            out.close();
        }
    }
    static class Print implements Runnable {
        private PipedReader in;

        public Print(PipedReader in) {
            this.in = in;
        }

        @Override
        public void run() {
            int receive = 0;
            try {
                while ((receive = in.read()) != -1) { 	// 会一直堵塞等待接收信息，知道对方输出关闭
                    System.out.print((char) receive);
                }
            } catch (IOException e) {}
        }
    }
}
```

##### **join() 使用:**

​    如果线程`A`  执行了`thread.join()`语句，其含义是：当前线程`A `等待`thread`线程终止后才从`thread.join()`返回，也就是说把当前线程加在`thread`后面，等他执行完后，才可能轮到本线程。

##### **ThreadLocal使用:**

​   `ThreadLocal`类用来提供线程内部的**局部变量**。这种变量在多线程环境下访问(通过`get`或`set`方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，也就是说仅共享初始值，之后相互独立，大概的实现就是**以当前线程为键，任意对象为值**。`ThreadLocal`实例通常来说都是`private static`类型的，用于关联线程和线程的上下文。

```java 
public class Profiler {
    // 申明一个本地变量
    private static final ThreadLocal<Long> TIME_THREADLOCAL = new ThreadLocal<Long>() {
        @Override
        protected Long initialValue() {
            return new Long(0);
        }
    };
    
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(new Thread1(TIME_THREADLOCAL),"thread1");
        Thread thread2 = new Thread(new Thread2(TIME_THREADLOCAL),"thread2");
        thread1.start();
        thread2.start();
    }
    
    static class Thread1 implements Runnable{
        private ThreadLocal<Long> threadLocal = null;

        public Thread1(ThreadLocal<Long> threadLocal) {
            this.threadLocal = threadLocal;
        }
        @Override
        public void run() {
            threadLocal.set(new Long(111));
            System.out.println(Thread.currentThread().getName() + " : " + threadLocal.get());
        }
    }

    static class Thread2 implements Runnable{
        private ThreadLocal<Long> threadLocal = null;
        public Thread2(ThreadLocal<Long> threadLocal) {
            this.threadLocal = threadLocal;
        }
        @Override
        public void run() {
            threadLocal.set(new Long(222));
            System.out.println(Thread.currentThread().getName() + " : " + threadLocal.get());
        }
    }
}
```

#####  线程应用实例

1. 等待超时模式，通过wait(long)来实现
2. 线程池技术 （需要维护两个容器就好，一个装job，一个装job消费者，有job来就通知消费者）

## Java中的锁——更加细腻的同步操作



































#### 其他一些常用的并发类

1. CountDownLatch

2. AtomicInteger,AtomicLong......等等Atomic系列

   ​


**参考资源：

> [Java 理论与实践: 处理 InterruptedException](https://www.ibm.com/developerworks/cn/java/j-jtp05236.html)

> [《Java并发编程的艺术》](https://book.douban.com/subject/26591326/)



















