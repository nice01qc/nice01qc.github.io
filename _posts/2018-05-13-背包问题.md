---
layout: post
title: "背包问题"
author: "nice01qc"
categories: "Algorithms"
excerpt_separator: "..."
---

> 背包问题...

**01背包**：

01背包（ZeroOnePack）: 有N件物品和一个容量为V的背包。（每种物品均只有一件）第i件物品的费用是`c[i]`，价值是`w[i]`。求解将哪些物品装入背包可使价值总和最大。

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。

用子问题定义状态：即`f[i][v]`表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：

`f[i][v] = max{ f[i-1][v], f[i-1][v-c[i]] + w[i] }`

```java
// 伪代码如下：
for i=1..N
   for v=V..0	// 逆序，保证只放一个
        f[v]=max{f[v],f[v-c[i]]+w[i]};
```



**完全背包：** 

完全背包(CompletePack): 有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是`c[i]`，价值是`w[i]`。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

即：

`f[i][v] = max { f[i-1][v-k*c[i]] + k*w[i] | 0 <= k*c[i] <= v }`

```java
// 伪代码如下：
for i=1..N
    for v=0..V	// 顺序，需要累计
        f[v]=max{f[v],f[v-c[i]]+w[i]}
```

**多重背包：**

多重背包(MultiplePack): 有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

即：

`f[i][v] = max{ f[i-1][v-k*c[i]] + k*w[i] | 0 <= k <= n[i]}`



> *关于返回背包路径问题，我只知道通过其二维坐标来反推....*





**参考资源：**

> [背包之01背包、完全背包、多重背包详解](http://www.cnblogs.com/tanky_woo/archive/2010/07/31/1789621.html)
>

















