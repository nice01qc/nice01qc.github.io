---
layout: post
title: "2-3查找树 -> 红黑树"
author: "nice01qc"
categorie: "Algorithms"
excerpt_separator: "..."
---

> 简单的介绍2-3查找树和红黑树的原理和实现细节...

**平衡二叉树：在二叉树的基础上，使树的高度最低，达到平衡**

```java
// node
private class Node {
    Key key;
    Value val;
    Node left, right;
    int N;
    boolean color;
    public Node(Key key, Value val, int N, boolean color){
        this.key = key;
        this.val = val;
        this.N = N;
        this.color = color;
    }
}
```

*2-3树：*

![2-3树]({{ site.url }}/assets/blogpicture/2-3树.jpg)

> **红黑树：**
>

左旋：

![左旋]({{ site.url }}/assets/blogpicture/左旋.gif)

```java
Node rotateLeft(Node h){		// 此旋转交换颜色
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    boolean tmp = x.color;
    x.color = h.color;
    h.color = tmp;
    x.N = h.N;
    h.N = 1 + size(h.left) + size(h.right);
    return x;
}
```

右旋：

![左旋]({{ site.url }}/assets/blogpicture/右旋.gif)

```java
Node rotateRight(Node h){		// 此旋转交换颜色
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    boolean tmp = x.color;
    x.color = h.color;
    h.color = tmp;
    x.N = h.N;
    h.N = 1 + size(h.left) + size(h.right);
    return x;
}
```

颜色转换（左右为红，根为黑，改为左右为黑，根为红）：

```java
void flipColor(Node h){
    h.color = RED;
    h.left.color = BLACK;
    h.right.color = BLACK;
}
```

插入算法：

```java
public void put(Key key, Value val){
    root = put(root, key, val);
    root.color = BLACK;
}
public Node put(Node h, Key key, Value val){
    if (h == null) return new Node(key,val,1,RED);
    int cmp = key.compareTo(h.key);
    if (cmp < 0) h.left = put(h.left, key, val);
    if (cmp > 0) h.right = put(h.right, key, val);
    if (cmp == 0) h.val = val;
    // 恢复颜色
    if (isRed(h.right) && !isRed(h.left)) h = rotateLeft(h);
    if (isRed(h.left) && isRed(h.left.left)) h = rotateright(h);
    if (isRed(h.left) && isRed(h.right)) flipColor(h);
    
    h.N = size(h.left) + size(h.right) + 1;
    return h;
}
```

普通的二叉树删除：

1. 如果删除的是叶节点，可以直接删除； 

2. 如果被删除的元素有一个子节点可以将子节点直接移到被删除元素的位置； 

3. 如果有两个子节点，这时候就可以把被删除元素的右支的最小节点（被删除元素右支的最左边的节点）和被删除元素互换，我们把被删除元素右支的最左边的节点称之为后继节点（后继元素），然后在根据情况1或者情况2进行操作。

   #### 在此基础进行改进，使删除后颜色恢复颜色平衡

   - 每一步都需要判断其左节点和左节点的左节点中至少有一个红色节点，否则通过颜色翻转，把左节点变成红色，这需要从根节点开始判断，以保证整体的颜色平衡。
   - 当被删除的元素没有子节点，且为红色，直接删除。
   - 当被删除的元素为根节点时，直接删除。
   - 当被删除的元素为黑色，且只有一个右节点为红色时，两者调换位置并将有节点颜色改为黑色，然后删除。
   - 当被删除元素为黑，且兄弟节点为黑，兄弟节点两个孩子也为黑，父节点为红，此时，交换兄弟节点与父节点的颜色；NIL元素是指每个叶节点都有两个空的，颜色为黑的NIL元素，需要他的时候就可以把它看成两个黑元素，不需要的时候可以忽视他。







